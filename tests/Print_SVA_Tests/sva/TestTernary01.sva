`define next_shift_amount 0 //IN CASE OF REQUIRED SIGNALS VALUES IN THE FUTURE, SHIFT YOUR ENTIRE TIMING BY THIS FACTOR

`include "ipc.sva"
`include "globalTypes.sva"
`include "TestTernary01_types.sva"
`include "TestTernary01_functions.sva"

import top_level_types::*;

module TestTernary01_verification(reset);

input reset;

//DESIGNER SHOULD PAY ATTENTION FOR USING THE MODEL CORRECT NAME TO REFER TO THE CLK SIGNAL USED IN IT
default clocking default_clk @(posedge TestTernary01.clk); endclocking
`include "TestTernary01_macros.sva"

////////////////////////////////////
//////////// Operations ////////////
////////////////////////////////////

sequence reset_sequence;
reset ##1 !reset;  	//DESIGNER REFER TO MODEL RESET SIGNAL HERE
endsequence

property reset_p;
	reset_sequence |->
	t##0 state_1() and
	t##0 data_out_sig() == 0 and
	t##0 valid() == 0 and
	t##0 value_in() == 0 and
	t##0 data_in_notify() == 1 and
	t##0 valid_out_notify() == 0;
endproperty
reset_a: assert property (reset_p);



property output1_2_3_p(o);
 bit[31:0] valid_f;
 bit[31:0] value_in_f;
	t ##0 hold(valid_f, valid()) and
	t ##0 hold(value_in_f, value_in()) and
	t##0 output1_2() and
	t##0 valid_out_sync()
implies
	t_end(o)##0 output2_3() and
	t_end(o)##0 data_out_sig() == valid_f and
	t_end(o)##0 valid() == valid_f and
	t_end(o)##0 valid_out_sig() == ((value_in_f <= 0)?0:1) and
	t_end(o)##0 value_in() == value_in_f and
	during_o (t, 1, t_end(o), 0, data_in_notify() == 0) and
	during_o (t, 1, t_end(o), -1, valid_out_notify() == 0) and
	t_end(o)##0 valid_out_notify() == 1;
endproperty;
output1_2_3_a: assert property (disable iff (reset) output1_2_3_p(1)); //ASSIGN t_end offset here



property output2_3_4_p(o);
 bit[31:0] data_out_sig_f;
 bit[31:0] valid_f;
 bit[31:0] value_in_f;
	t ##0 hold(data_out_sig_f, data_out_sig()) and
	t ##0 hold(valid_f, valid()) and
	t ##0 hold(value_in_f, value_in()) and
	t##0 output2_3() and
	t##0 valid_out_sync()
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data_out_sig() == data_out_sig_f and
	t_end(o)##0 valid() == valid_f and
	t_end(o)##0 value_in() == value_in_f and
	during_o (t, 1, t_end(o), -1, data_in_notify() == 0) and
	t_end(o)##0 data_in_notify() == 1 and
	during_o (t, 1, t_end(o), 0, valid_out_notify() == 0);
endproperty;
output2_3_4_a: assert property (disable iff (reset) output2_3_4_p(1)); //ASSIGN t_end offset here



property state_1_1_p(o);
 bit[31:0] data_in_sig_f;
	t ##0 hold(data_in_sig_f, data_in_sig()) and
	t##0 state_1() and
	t##0 data_in_sync() and
	t##0 (data_in_sig() >= 5)
implies
	t_end(o)##0 output1_2() and
	t_end(o)##0 data_out_sig() == 1 and
	t_end(o)##0 valid() == 1 and
	t_end(o)##0 valid_out_sig() == (1 + (1 + data_in_sig_f)) and
	t_end(o)##0 value_in() == data_in_sig_f and
	during_o (t, 1, t_end(o), 0, data_in_notify() == 0) and
	during_o (t, 1, t_end(o), -1, valid_out_notify() == 0) and
	t_end(o)##0 valid_out_notify() == 1;
endproperty;
state_1_1_a: assert property (disable iff (reset) state_1_1_p(1)); //ASSIGN t_end offset here



property state_1_2_p(o);
 bit[31:0] data_in_sig_f;
	t ##0 hold(data_in_sig_f, data_in_sig()) and
	t##0 state_1() and
	t##0 data_in_sync() and
	t##0 (data_in_sig() <= 4)
implies
	t_end(o)##0 output1_2() and
	t_end(o)##0 data_out_sig() == 1 and
	t_end(o)##0 valid() == 1 and
	t_end(o)##0 valid_out_sig() == (1 + data_in_sig_f) and
	t_end(o)##0 value_in() == data_in_sig_f and
	during_o (t, 1, t_end(o), 0, data_in_notify() == 0) and
	during_o (t, 1, t_end(o), -1, valid_out_notify() == 0) and
	t_end(o)##0 valid_out_notify() == 1;
endproperty;
state_1_2_a: assert property (disable iff (reset) state_1_2_p(1)); //ASSIGN t_end offset here



property state_1_5_p(o);
 bit[31:0] value_in_f;
	t ##0 hold(value_in_f, value_in()) and
	t##0 state_1() and
	t##0 !(data_in_sync()) and
	t##0 (value_in() >= 6)
implies
	t_end(o)##0 output1_2() and
	t_end(o)##0 data_out_sig() == 0 and
	t_end(o)##0 valid() == 0 and
	t_end(o)##0 valid_out_sig() == (1 + value_in_f) and
	t_end(o)##0 value_in() == value_in_f and
	during_o (t, 1, t_end(o), 0, data_in_notify() == 0) and
	during_o (t, 1, t_end(o), -1, valid_out_notify() == 0) and
	t_end(o)##0 valid_out_notify() == 1;
endproperty;
state_1_5_a: assert property (disable iff (reset) state_1_5_p(1)); //ASSIGN t_end offset here



property state_1_6_p(o);
 bit[31:0] value_in_f;
	t ##0 hold(value_in_f, value_in()) and
	t##0 state_1() and
	t##0 !(data_in_sync()) and
	t##0 (value_in() <= 5)
implies
	t_end(o)##0 output1_2() and
	t_end(o)##0 data_out_sig() == 0 and
	t_end(o)##0 valid() == 0 and
	t_end(o)##0 valid_out_sig() == value_in_f and
	t_end(o)##0 value_in() == value_in_f and
	during_o (t, 1, t_end(o), 0, data_in_notify() == 0) and
	during_o (t, 1, t_end(o), -1, valid_out_notify() == 0) and
	t_end(o)##0 valid_out_notify() == 1;
endproperty;
state_1_6_a: assert property (disable iff (reset) state_1_6_p(1)); //ASSIGN t_end offset here



property wait_output1_2_p(o);
 bit[31:0] data_out_sig_f;
 bit[31:0] valid_f;
 bit[31:0] valid_out_sig_f;
 bit[31:0] value_in_f;
	t ##0 hold(data_out_sig_f, data_out_sig()) and
	t ##0 hold(valid_f, valid()) and
	t ##0 hold(valid_out_sig_f, valid_out_sig()) and
	t ##0 hold(value_in_f, value_in()) and
	t##0 output1_2() and
	t##0 !(valid_out_sync())
implies
	t##1 output1_2() and
	t##1 data_out_sig() == data_out_sig_f and
	t##1 valid() == valid_f and
	t##1 valid_out_sig() == valid_out_sig_f and
	t##1 value_in() == value_in_f and
	t##1 data_in_notify() == 0 and
	t##1 valid_out_notify() == 1;
endproperty;
wait_output1_2_a: assert property (disable iff (reset) wait_output1_2_p(1)); //ASSIGN t_end offset here



property wait_output2_3_p(o);
 bit[31:0] data_out_sig_f;
 bit[31:0] valid_f;
 bit[31:0] valid_out_sig_f;
 bit[31:0] value_in_f;
	t ##0 hold(data_out_sig_f, data_out_sig()) and
	t ##0 hold(valid_f, valid()) and
	t ##0 hold(valid_out_sig_f, valid_out_sig()) and
	t ##0 hold(value_in_f, value_in()) and
	t##0 output2_3() and
	t##0 !(valid_out_sync())
implies
	t##1 output2_3() and
	t##1 data_out_sig() == data_out_sig_f and
	t##1 valid() == valid_f and
	t##1 valid_out_sig() == valid_out_sig_f and
	t##1 value_in() == value_in_f and
	t##1 data_in_notify() == 0 and
	t##1 valid_out_notify() == 1;
endproperty;
wait_output2_3_a: assert property (disable iff (reset) wait_output2_3_p(1)); //ASSIGN t_end offset here



endmodule

//DESIGNER SHOULD PAY ATTENTION FOR USING THE MODEL CORRECT NAME FOR BINDING AND TO REFER TO THE RESET SIGNAL USED IN IT
bind TestTernary01 TestTernary01_verification inst (.*, .reset());
