`define next_shift_amount 0 //IN CASE OF REQUIRED SIGNALS VALUES IN THE FUTURE, SHIFT YOUR ENTIRE TIMING BY THIS FACTOR

`include "ipc.sva"
`include "globalTypes.sva"
`include "TestMasterSlave23_types.sva"
`include "TestMasterSlave23_functions.sva"

import top_level_types::*;

module TestMasterSlave23_verification(reset);

input reset;

//DESIGNER SHOULD PAY ATTENTION FOR USING THE MODEL CORRECT NAME TO REFER TO THE CLK SIGNAL USED IN IT
default clocking default_clk @(posedge TestMasterSlave23.clk); endclocking
`include "TestMasterSlave23_macros.sva"

////////////////////////////////////
//////////// Operations ////////////
////////////////////////////////////

sequence reset_sequence;
reset ##1 !reset;  	//DESIGNER REFER TO MODEL RESET SIGNAL HERE
endsequence

property reset_p;
	reset_sequence |->
	t##0 state_1() and
	t##0 data3() == 0;
endproperty
reset_a: assert property (reset_p);



property state_1_1_p(o);
 bit[31:0] s_in_3_sig_f;
	t ##0 hold(s_in_3_sig_f, s_in_3_sig()) and
	t##0 state_1() and
	t##0 s_in_1_sync() and
	t##0 s_in_2_sync() and
	t##0 s_in_3_sync() and
	t##0 (s_in_3_sig() >= 6)
implies
	t_end(o)##0 state_2() and
	t_end(o)##0 data3() == s_in_3_sig_f;
endproperty;
state_1_1_a: assert property (disable iff (reset) state_1_1_p(1)); //ASSIGN t_end offset here



property state_1_10_p(o);
 bit[31:0] data3_f;
	t ##0 hold(data3_f, data3()) and
	t##0 state_1() and
	t##0 s_in_1_sync() and
	t##0 s_in_2_sync() and
	t##0 !(s_in_3_sync()) and
	t##0 (data3() <= 5)
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == data3_f;
endproperty;
state_1_10_a: assert property (disable iff (reset) state_1_10_p(1)); //ASSIGN t_end offset here



property state_1_11_p(o);
 bit[31:0] s_in_3_sig_f;
	t ##0 hold(s_in_3_sig_f, s_in_3_sig()) and
	t##0 state_1() and
	t##0 s_in_1_sync() and
	t##0 !(s_in_2_sync()) and
	t##0 s_in_3_sync() and
	t##0 (s_in_3_sig() <= 5)
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == s_in_3_sig_f;
endproperty;
state_1_11_a: assert property (disable iff (reset) state_1_11_p(1)); //ASSIGN t_end offset here



property state_1_12_p(o);
 bit[31:0] data3_f;
	t ##0 hold(data3_f, data3()) and
	t##0 state_1() and
	t##0 s_in_1_sync() and
	t##0 !(s_in_2_sync()) and
	t##0 !(s_in_3_sync()) and
	t##0 (data3() <= 5)
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == data3_f;
endproperty;
state_1_12_a: assert property (disable iff (reset) state_1_12_p(1)); //ASSIGN t_end offset here



property state_1_13_p(o);
 bit[31:0] s_in_3_sig_f;
	t ##0 hold(s_in_3_sig_f, s_in_3_sig()) and
	t##0 state_1() and
	t##0 !(s_in_1_sync()) and
	t##0 s_in_2_sync() and
	t##0 s_in_3_sync() and
	t##0 (s_in_3_sig() <= 5)
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == s_in_3_sig_f;
endproperty;
state_1_13_a: assert property (disable iff (reset) state_1_13_p(1)); //ASSIGN t_end offset here



property state_1_14_p(o);
 bit[31:0] data3_f;
	t ##0 hold(data3_f, data3()) and
	t##0 state_1() and
	t##0 !(s_in_1_sync()) and
	t##0 s_in_2_sync() and
	t##0 !(s_in_3_sync()) and
	t##0 (data3() <= 5)
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == data3_f;
endproperty;
state_1_14_a: assert property (disable iff (reset) state_1_14_p(1)); //ASSIGN t_end offset here



property state_1_15_p(o);
 bit[31:0] s_in_3_sig_f;
	t ##0 hold(s_in_3_sig_f, s_in_3_sig()) and
	t##0 state_1() and
	t##0 !(s_in_1_sync()) and
	t##0 !(s_in_2_sync()) and
	t##0 s_in_3_sync() and
	t##0 (s_in_3_sig() <= 5)
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == s_in_3_sig_f;
endproperty;
state_1_15_a: assert property (disable iff (reset) state_1_15_p(1)); //ASSIGN t_end offset here



property state_1_16_p(o);
 bit[31:0] data3_f;
	t ##0 hold(data3_f, data3()) and
	t##0 state_1() and
	t##0 !(s_in_1_sync()) and
	t##0 !(s_in_2_sync()) and
	t##0 !(s_in_3_sync()) and
	t##0 (data3() <= 5)
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == data3_f;
endproperty;
state_1_16_a: assert property (disable iff (reset) state_1_16_p(1)); //ASSIGN t_end offset here



property state_1_2_p(o);
 bit[31:0] data3_f;
	t ##0 hold(data3_f, data3()) and
	t##0 state_1() and
	t##0 s_in_1_sync() and
	t##0 s_in_2_sync() and
	t##0 !(s_in_3_sync()) and
	t##0 (data3() >= 6)
implies
	t_end(o)##0 state_2() and
	t_end(o)##0 data3() == data3_f;
endproperty;
state_1_2_a: assert property (disable iff (reset) state_1_2_p(1)); //ASSIGN t_end offset here



property state_1_3_p(o);
 bit[31:0] s_in_3_sig_f;
	t ##0 hold(s_in_3_sig_f, s_in_3_sig()) and
	t##0 state_1() and
	t##0 s_in_1_sync() and
	t##0 !(s_in_2_sync()) and
	t##0 s_in_3_sync() and
	t##0 (s_in_3_sig() >= 6)
implies
	t_end(o)##0 state_2() and
	t_end(o)##0 data3() == s_in_3_sig_f;
endproperty;
state_1_3_a: assert property (disable iff (reset) state_1_3_p(1)); //ASSIGN t_end offset here



property state_1_4_p(o);
 bit[31:0] data3_f;
	t ##0 hold(data3_f, data3()) and
	t##0 state_1() and
	t##0 s_in_1_sync() and
	t##0 !(s_in_2_sync()) and
	t##0 !(s_in_3_sync()) and
	t##0 (data3() >= 6)
implies
	t_end(o)##0 state_2() and
	t_end(o)##0 data3() == data3_f;
endproperty;
state_1_4_a: assert property (disable iff (reset) state_1_4_p(1)); //ASSIGN t_end offset here



property state_1_5_p(o);
 bit[31:0] s_in_3_sig_f;
	t ##0 hold(s_in_3_sig_f, s_in_3_sig()) and
	t##0 state_1() and
	t##0 !(s_in_1_sync()) and
	t##0 s_in_2_sync() and
	t##0 s_in_3_sync() and
	t##0 (s_in_3_sig() >= 6)
implies
	t_end(o)##0 state_2() and
	t_end(o)##0 data3() == s_in_3_sig_f;
endproperty;
state_1_5_a: assert property (disable iff (reset) state_1_5_p(1)); //ASSIGN t_end offset here



property state_1_6_p(o);
 bit[31:0] data3_f;
	t ##0 hold(data3_f, data3()) and
	t##0 state_1() and
	t##0 !(s_in_1_sync()) and
	t##0 s_in_2_sync() and
	t##0 !(s_in_3_sync()) and
	t##0 (data3() >= 6)
implies
	t_end(o)##0 state_2() and
	t_end(o)##0 data3() == data3_f;
endproperty;
state_1_6_a: assert property (disable iff (reset) state_1_6_p(1)); //ASSIGN t_end offset here



property state_1_7_p(o);
 bit[31:0] s_in_3_sig_f;
	t ##0 hold(s_in_3_sig_f, s_in_3_sig()) and
	t##0 state_1() and
	t##0 !(s_in_1_sync()) and
	t##0 !(s_in_2_sync()) and
	t##0 s_in_3_sync() and
	t##0 (s_in_3_sig() >= 6)
implies
	t_end(o)##0 state_2() and
	t_end(o)##0 data3() == s_in_3_sig_f;
endproperty;
state_1_7_a: assert property (disable iff (reset) state_1_7_p(1)); //ASSIGN t_end offset here



property state_1_8_p(o);
 bit[31:0] data3_f;
	t ##0 hold(data3_f, data3()) and
	t##0 state_1() and
	t##0 !(s_in_1_sync()) and
	t##0 !(s_in_2_sync()) and
	t##0 !(s_in_3_sync()) and
	t##0 (data3() >= 6)
implies
	t_end(o)##0 state_2() and
	t_end(o)##0 data3() == data3_f;
endproperty;
state_1_8_a: assert property (disable iff (reset) state_1_8_p(1)); //ASSIGN t_end offset here



property state_1_9_p(o);
 bit[31:0] s_in_3_sig_f;
	t ##0 hold(s_in_3_sig_f, s_in_3_sig()) and
	t##0 state_1() and
	t##0 s_in_1_sync() and
	t##0 s_in_2_sync() and
	t##0 s_in_3_sync() and
	t##0 (s_in_3_sig() <= 5)
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == s_in_3_sig_f;
endproperty;
state_1_9_a: assert property (disable iff (reset) state_1_9_p(1)); //ASSIGN t_end offset here



property state_2_17_p(o);
 bit[31:0] s_in_3_sig_f;
	t ##0 hold(s_in_3_sig_f, s_in_3_sig()) and
	t##0 state_2() and
	t##0 s_in_1_sync() and
	t##0 s_in_2_sync() and
	t##0 s_in_3_sync()
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == s_in_3_sig_f;
endproperty;
state_2_17_a: assert property (disable iff (reset) state_2_17_p(1)); //ASSIGN t_end offset here



property state_2_18_p(o);
 bit[31:0] data3_f;
	t ##0 hold(data3_f, data3()) and
	t##0 state_2() and
	t##0 s_in_1_sync() and
	t##0 s_in_2_sync() and
	t##0 !(s_in_3_sync())
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == data3_f;
endproperty;
state_2_18_a: assert property (disable iff (reset) state_2_18_p(1)); //ASSIGN t_end offset here



property state_2_19_p(o);
 bit[31:0] s_in_3_sig_f;
	t ##0 hold(s_in_3_sig_f, s_in_3_sig()) and
	t##0 state_2() and
	t##0 s_in_1_sync() and
	t##0 !(s_in_2_sync()) and
	t##0 s_in_3_sync()
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == s_in_3_sig_f;
endproperty;
state_2_19_a: assert property (disable iff (reset) state_2_19_p(1)); //ASSIGN t_end offset here



property state_2_20_p(o);
 bit[31:0] data3_f;
	t ##0 hold(data3_f, data3()) and
	t##0 state_2() and
	t##0 s_in_1_sync() and
	t##0 !(s_in_2_sync()) and
	t##0 !(s_in_3_sync())
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == data3_f;
endproperty;
state_2_20_a: assert property (disable iff (reset) state_2_20_p(1)); //ASSIGN t_end offset here



property state_2_21_p(o);
 bit[31:0] s_in_3_sig_f;
	t ##0 hold(s_in_3_sig_f, s_in_3_sig()) and
	t##0 state_2() and
	t##0 !(s_in_1_sync()) and
	t##0 s_in_2_sync() and
	t##0 s_in_3_sync()
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == s_in_3_sig_f;
endproperty;
state_2_21_a: assert property (disable iff (reset) state_2_21_p(1)); //ASSIGN t_end offset here



property state_2_22_p(o);
 bit[31:0] data3_f;
	t ##0 hold(data3_f, data3()) and
	t##0 state_2() and
	t##0 !(s_in_1_sync()) and
	t##0 s_in_2_sync() and
	t##0 !(s_in_3_sync())
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == data3_f;
endproperty;
state_2_22_a: assert property (disable iff (reset) state_2_22_p(1)); //ASSIGN t_end offset here



property state_2_23_p(o);
 bit[31:0] s_in_3_sig_f;
	t ##0 hold(s_in_3_sig_f, s_in_3_sig()) and
	t##0 state_2() and
	t##0 !(s_in_1_sync()) and
	t##0 !(s_in_2_sync()) and
	t##0 s_in_3_sync()
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == s_in_3_sig_f;
endproperty;
state_2_23_a: assert property (disable iff (reset) state_2_23_p(1)); //ASSIGN t_end offset here



property state_2_24_p(o);
 bit[31:0] data3_f;
	t ##0 hold(data3_f, data3()) and
	t##0 state_2() and
	t##0 !(s_in_1_sync()) and
	t##0 !(s_in_2_sync()) and
	t##0 !(s_in_3_sync())
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 data3() == data3_f;
endproperty;
state_2_24_a: assert property (disable iff (reset) state_2_24_p(1)); //ASSIGN t_end offset here



endmodule

//DESIGNER SHOULD PAY ATTENTION FOR USING THE MODEL CORRECT NAME FOR BINDING AND TO REFER TO THE RESET SIGNAL USED IN IT
bind TestMasterSlave23 TestMasterSlave23_verification inst (.*, .reset());
