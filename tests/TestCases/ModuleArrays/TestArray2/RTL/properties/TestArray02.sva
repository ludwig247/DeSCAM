`define next_shift_amount 0 //IN CASE OF REQUIRED SIGNALS VALUES IN THE FUTURE, SHIFT YOUR ENTIRE TIMING BY THIS FACTOR

`include "ipc.sva"
`include "TestArray02_types.sva"
`include "globalTypes.sva"
`include "TestArray02_functions.sva"

import top_level_types::*;

module TestArray02_verification(reset);

input reset;

//DESIGNER SHOULD PAY ATTENTION FOR USING THE MODEL CORRECT NAME TO REFER TO THE CLK SIGNAL USED IN IT
default clocking default_clk @(posedge TestArray02.clk); endclocking
`include "TestArray02_macros.sva"

////////////////////////////////////
//////////// Operations ////////////
////////////////////////////////////

sequence reset_sequence;
reset ##1 !reset;  	//DESIGNER REFER TO MODEL RESET SIGNAL HERE
endsequence

property reset_p;
	reset_sequence |->
	t##0 state_1() and
	t##0 myArray_0() == 0 and
	t##0 myArray_1() == 0 and
	t##0 myArray_2() == 0 and
	t##0 myArray_3() == 0 and
	t##0 myArray_4() == 0 and
	t##0 b_in_notify() == 1 and
	t##0 b_out_notify() == 0;
endproperty
reset_a: assert property (reset_p);



property b_in_range;
	b_in_sig() >= 0 and b_in_sig() < 5;
endproperty;
b_in_range_a: assume property (disable iff (reset) b_in_range);

property state_1_1_p(o);
 bit[31:0] b_in_sig_f;
 bit[31:0] myArray_f [4:0];
 bit[31:0] myArray_1_f;
 bit[31:0] myArray_2_f;
 bit[31:0] myArray_3_f;
 bit[31:0] myArray_4_f;
	t ##0 hold(b_in_sig_f, b_in_sig()) and
	t ##0 hold(myArray_f, myArray()) and
	t ##0 hold(myArray_1_f, myArray_1()) and
	t ##0 hold(myArray_2_f, myArray_2()) and
	t ##0 hold(myArray_3_f, myArray_3()) and
	t ##0 hold(myArray_4_f, myArray_4()) and
	t##0 state_1() and
	t##0 b_in_sync()
implies
	t_end(o)##0 state_2() and
	t_end(o)##0 b_out_sig() == myArray_f[b_in_sig_f] and
	t_end(o)##0 myArray_0() == myArray_f[b_in_sig_f] and
	t_end(o)##0 myArray_1() == myArray_1_f and
	t_end(o)##0 myArray_2() == myArray_2_f and
	t_end(o)##0 myArray_3() == myArray_3_f and
	t_end(o)##0 myArray_4() == myArray_4_f and
	during_o (t, 1, t_end(o), 0, b_in_notify() == 0) and
	during_o (t, 1, t_end(o), -1, b_out_notify() == 0) and
	t_end(o)##0 b_out_notify() == 1;
endproperty;
state_1_1_a: assert property (disable iff (reset) state_1_1_p(1)); //ASSIGN t_end offset here



property state_2_2_p(o);
 bit[31:0] myArray_0_f;
 bit[31:0] myArray_1_f;
 bit[31:0] myArray_2_f;
 bit[31:0] myArray_3_f;
 bit[31:0] myArray_4_f;
	t ##0 hold(myArray_0_f, myArray_0()) and
	t ##0 hold(myArray_1_f, myArray_1()) and
	t ##0 hold(myArray_2_f, myArray_2()) and
	t ##0 hold(myArray_3_f, myArray_3()) and
	t ##0 hold(myArray_4_f, myArray_4()) and
	t##0 state_2() and
	t##0 b_out_sync()
implies
	t_end(o)##0 state_1() and
	t_end(o)##0 myArray_0() == myArray_0_f and
	t_end(o)##0 myArray_1() == myArray_1_f and
	t_end(o)##0 myArray_2() == myArray_2_f and
	t_end(o)##0 myArray_3() == myArray_3_f and
	t_end(o)##0 myArray_4() == myArray_4_f and
	during_o (t, 1, t_end(o), -1, b_in_notify() == 0) and
	t_end(o)##0 b_in_notify() == 1 and
	during_o (t, 1, t_end(o), 0, b_out_notify() == 0);
endproperty;
state_2_2_a: assert property (disable iff (reset) state_2_2_p(1)); //ASSIGN t_end offset here



property wait_state_1_p(o);
 bit[31:0] myArray_0_f;
 bit[31:0] myArray_1_f;
 bit[31:0] myArray_2_f;
 bit[31:0] myArray_3_f;
 bit[31:0] myArray_4_f;
	t ##0 hold(myArray_0_f, myArray_0()) and
	t ##0 hold(myArray_1_f, myArray_1()) and
	t ##0 hold(myArray_2_f, myArray_2()) and
	t ##0 hold(myArray_3_f, myArray_3()) and
	t ##0 hold(myArray_4_f, myArray_4()) and
	t##0 state_1() and
	t##0 !(b_in_sync())
implies
	t##1 state_1() and
	t##1 myArray_0() == myArray_0_f and
	t##1 myArray_1() == myArray_1_f and
	t##1 myArray_2() == myArray_2_f and
	t##1 myArray_3() == myArray_3_f and
	t##1 myArray_4() == myArray_4_f and
	t##1 b_in_notify() == 1 and
	t##1 b_out_notify() == 0;
endproperty;
wait_state_1_a: assert property (disable iff (reset) wait_state_1_p(1)); //ASSIGN t_end offset here



property wait_state_2_p(o);
 bit[31:0] b_out_sig_f;
 bit[31:0] myArray_0_f;
 bit[31:0] myArray_1_f;
 bit[31:0] myArray_2_f;
 bit[31:0] myArray_3_f;
 bit[31:0] myArray_4_f;
	t ##0 hold(b_out_sig_f, b_out_sig()) and
	t ##0 hold(myArray_0_f, myArray_0()) and
	t ##0 hold(myArray_1_f, myArray_1()) and
	t ##0 hold(myArray_2_f, myArray_2()) and
	t ##0 hold(myArray_3_f, myArray_3()) and
	t ##0 hold(myArray_4_f, myArray_4()) and
	t##0 state_2() and
	t##0 !(b_out_sync())
implies
	t##1 state_2() and
	t##1 b_out_sig() == b_out_sig_f and
	t##1 myArray_0() == myArray_0_f and
	t##1 myArray_1() == myArray_1_f and
	t##1 myArray_2() == myArray_2_f and
	t##1 myArray_3() == myArray_3_f and
	t##1 myArray_4() == myArray_4_f and
	t##1 b_in_notify() == 0 and
	t##1 b_out_notify() == 1;
endproperty;
wait_state_2_a: assert property (disable iff (reset) wait_state_2_p(1)); //ASSIGN t_end offset here



endmodule

//DESIGNER SHOULD PAY ATTENTION FOR USING THE MODEL CORRECT NAME FOR BINDING AND TO REFER TO THE RESET SIGNAL USED IN IT
bind TestArray02 TestArray02_verification inst (.*, .reset(rst));
